module XMPP.Stanza.Message
    exposing
    -- Types
    ( Message
    , Attributes
    , Type

    -- Construct
    , chat
    , groupchat
    , error
    , headline
    , normal
    , body

    -- Inspect
    , inspect

    -- XML
    , toXml
    , fromXml
    )

{-| Message

# Types

@doc Message, Attributes, Type

# Constructing Message Stanzas

@doc chat, groupchat, error, headline, normal

# Constructing common XML nodes

@doc body

# Inspecting a Message Stanza

@doc inspect

# Encoding to XML

@doc toXml

# Decoding from XML

@doc fromXml

 -}

import XmlParser exposing (..)
import XMPP.Stanza.Utils as Utils
import XMPP.JID as JID exposing (JID)

------------------------------------------------------------
-- Types
------------------------------------------------------------

type Message = Message Attributes (List Node)

type alias Attributes =
    { to      : Maybe JID
    , from    : Maybe JID
    , type_   : Type
    , id      : Maybe String
    , xmllang : Maybe String
    }

def : Attributes
def =
    { to      = Nothing
    , from    = Nothing
    , type_   = Normal
    , id      = Nothing
    , xmllang = Nothing
    }

{-
Page 71 of https://datatracker.ietf.org/doc/rfc6121/

  o  chat -- The message is sent in the context of a one-to-one chat
      session.  Typically an interactive client will present a message
      of type "chat" in an interface that enables one-to-one chat
      between the two parties, including an appropriate conversation
      history.  Detailed recommendations regarding one-to-one chat
      sessions are provided under Section 5.1.

   o  error -- The message is generated by an entity that experiences an
      error when processing a message received from another entity (for
      details regarding stanza error syntax, refer to [XMPP-CORE]).  A
      client that receives a message of type "error" SHOULD present an
      appropriate interface informing the original sender regarding the
      nature of the error.

   o  groupchat -- The message is sent in the context of a multi-user
      chat environment (similar to that of [IRC]).  Typically a
      receiving client will present a message of type "groupchat" in an
      interface that enables many-to-many chat between the parties,
      including a roster of parties in the chatroom and an appropriate
      conversation history.  For detailed information about XMPP-based
      groupchat, refer to [XEP-0045].

   o  headline -- The message provides an alert, a notification, or
      other transient information to which no reply is expected (e.g.,
      news headlines, sports updates, near-real-time market data, or
      syndicated content).  Because no reply to the message is expected,
      typically a receiving client will present a message of type
      "headline" in an interface that appropriately differentiates the
      message from standalone messages, chat messages, and groupchat
      messages (e.g., by not providing the recipient with the ability to
      reply).  If the 'to' address is the bare JID, the receiving server
      SHOULD deliver the message to all of the recipient's available
      resources with non-negative presence priority and MUST deliver the
      message to at least one of those resources; if the 'to' address is
      a full JID and there is a matching resource, the server MUST
      deliver the message to that resource; otherwise the server MUST
      either silently ignore the message or return an error (see
      Section 8).

   o  normal -- The message is a standalone message that is sent outside
      the context of a one-to-one conversation or groupchat, and to
      which it is expected that the recipient will reply.  Typically a
      receiving client will present a message of type "normal" in an
      interface that enables the recipient to reply, but without a
      conversation history.  The default value of the 'type' attribute
      is "normal".
-}

type Type
    = Chat
    | Groupchat
    | Error
    | Headline
    | Normal


------------------------------------------------------------
-- Constructing Message Stanzas
------------------------------------------------------------


{-| Generic message constuctor meant for internal use only.

 -}
message : Maybe JID -> Type -> List Node -> Message
message to type_ nodes =
    Message
    { to      = to
    , from    = Nothing
    , type_   = type_
    , id      = Nothing
    , xmllang = Nothing
    }
    nodes


{-| Construct a `chat` message stanza.

Use this to construct a private message that you want to send to an
individual entity.

 -}
chat : JID -> List Node -> Message
chat to = message (Just to) Chat


{-| Construct a `groupchat` message stanza.

Use this when you want to construct a message that you can send to a
Multi-User Chat (MUC) room, where the JID identifies the room.

 -}
groupchat : JID -> List Node -> Message
groupchat to = message (Just to) Groupchat


{-| Construct an `error` message stanza.

You probably won't need this, but if you do, you'll know.

 -}
error : JID -> List Node -> Message
error to = message (Just to) Error


{-| Construct a `headline` message stanza.

You probably won't need this, but if you do, you'll know.

 -}
headline : JID -> List Node -> Message
headline to = message (Just to) Headline


{-| Construct a `normal` message stanza.

You probably won't need this, but if you do, you'll know.

 -}
normal : JID -> List Node -> Message
normal to = message (Just to) Normal


------------------------------------------------------------
-- Constructing common XML nodes
------------------------------------------------------------


{-| Construct an XML `body` node.

This is often used inside of a `message` stanza.

    chat alice [ body "Hello Alice!" ]

 -}
body : String -> Node
body s = Element "body" [] [ Text s ]


------------------------------------------------------------
-- Inspecting a Message Stanza
------------------------------------------------------------

inspect : Message -> (Attributes, List Node)
inspect (Message attrs nodes) = (attrs, nodes)


------------------------------------------------------------
-- Encoding to XML
------------------------------------------------------------

showType : Type -> String
showType type_ =
    case type_ of
        Chat      -> "chat"
        Groupchat -> "groupchat"
        Error     -> "error"
        Headline  -> "headline"
        Normal    -> "normal"


{-| Encode a Message to an XML Node.

 -}
toXml : Message -> Node
toXml (Message { to, from, type_, id, xmllang } nodes) =
    let
        fromJID = Maybe.withDefault "" << Maybe.map JID.toString
        toString = Maybe.withDefault ""
        attrs = Utils.filterAttributes
                [ Attribute "to"       (fromJID to)
                , Attribute "from"     (fromJID from)
                , Attribute "type"     (showType type_)
                , Attribute "id"       (toString id)
                , Attribute "xml:lang" (toString xmllang)
                , Attribute "xmlns"    "jabber:client"
                ]
    in
        Element "message" attrs nodes


------------------------------------------------------------
-- Decoding from XML
------------------------------------------------------------

{-| Decode a Message stanza from an XML Node.

 -}
fromXml : Node -> Result String Message
fromXml node =
    case node of
        Element "message" attrs children ->
            Ok (Message (toAttributes attrs) children)
        _ ->
            Err "invalid message stanza"

toAttributes : List Attribute -> Attributes
toAttributes =
    List.foldl updateAttribute def

updateAttribute : Attribute -> Attributes -> Attributes
updateAttribute { name, value } attrs =
    case name of
        "to" ->
            Utils.updateAttributeTo value attrs

        "from" ->
            Utils.updateAttributeFrom value attrs

        "type" ->
            updateAttributeType value attrs

        "id" ->
            Utils.updateAttributeId value attrs

        "xml:lang" ->
            Utils.updateAttributeXmllang value attrs

        _ ->
            attrs

updateAttributeType : String -> { r | type_ : Type } -> { r | type_ : Type }
updateAttributeType value attrs =
    case readType value of
        Just type_ ->
            { attrs | type_ = type_ }

        Nothing ->
            attrs

readType : String -> Maybe Type
readType s =
    case s of
        "chat"      -> Just Chat
        "groupchat" -> Just Groupchat
        "error"     -> Just Error
        "headline"  -> Just Headline
        "normal"    -> Just Normal
        ""          -> Just Normal
        _           -> Nothing

